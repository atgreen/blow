(in-package :bknr.htmlize)

(defun xml-escape (xml-string)
  (apply #'concatenate 'string
         (loop for c across xml-string
	     collect (case c
		       ((#\<) "&lt;")
		       ((#\>) "&gt;")
		       ((#\&) "&amp;")
		       (t (string c))))))

(defun write-span (spanclass string)
  (format t "<span class=\"~a\">~a</span>"
	  spanclass (xml-escape string)))

(defun quoted-string-p (string)
  (string-delimited-by-p string #\"))

(defun comment-string-p (string)
  (string-beginning-with-p string ";"))

(defun global-string-p (string)
  (or (string-delimited-by-p string #\*)
      (string-delimited-by-p string #\+)))

(defun keyword-string-p (string)
  (string-beginning-with-p string ":"))

(defun char-string-p (string)
  (string-beginning-with-p string "\#\\"))

(defun keyword-to-html (keyword)
  (let ((hyperspec-url (hyperspec-url keyword)))
    (if hyperspec-url
	(format nil "<span class=\"keyword\"><a href=\"~a\">~a</a></span>" hyperspec-url keyword)
	keyword)))

(defun write-keyword (keyword)
  (write-string (keyword-to-html keyword)))

(defun defun-to-html (form)
  (princ #\()
  (write-string (pop form))
  (write-keyword (pop form))
  (write-string (pop form))
  (let ((fun (pop form)))
    (if (consp fun)
	(to-html fun)
	(write-span "function-name" fun)))
  (write-string (pop form))
  (to-html (pop form) :plain t)
  (when (car form)
    (write-string (pop form)))
  (mapc #'to-html form)
  (princ #\)))

(defun special-plain-to-html (form)
  (princ #\()
  (write-string (pop form))
  (write-keyword (pop form))
  (write-string (pop form))
  (mapc #'(lambda (f) (to-html f :plain t)) form)
  (princ #\)))

(defun special-plain-body-to-html (form)
  (princ #\()
  (write-string (pop form))
  (write-keyword (pop form))
  (write-string (pop form))
  (to-html (pop form) :plain t)
  (when form
    (write-string (pop form)))
  (mapc #'to-html form)
  (princ #\)))

(defun special-1-to-html (form)
  (princ #\()
  (write-string (pop form))
  (write-keyword (pop form))
  (let ((rest (pop form)))
    (when rest (write-string rest)))
  (mapc #'to-html form)
  (princ #\)))

(defparameter *keyword-html-functions*
  `(("defun" ,#'defun-to-html)
    ("defmethod" ,#'defun-to-html)
    ("defgeneric" ,#'defun-to-html)
    ("eval-when" ,#'special-plain-body-to-html)
    ("in-package" ,#'special-1-to-html)
    ("use-package" ,#'special-1-to-html)
    ("defconstant" ,#'special-1-to-html)
    ("defparameter" ,#'special-1-to-html)
    ("defvar" ,#'special-1-to-html)
    ("let" ,#'special-plain-body-to-html)
    ("let*" ,#'special-plain-body-to-html)
    ("defclass" ,#'special-plain-to-html)
    ("defstruct" ,#'special-plain-to-html)    
    ("defpackage" ,#'special-plain-to-html)
    ("defsystem" ,#'special-plain-to-html)    
    ("declare" ,#'special-plain-to-html)    
    ))

(defun keyword-html-function (keyword)
  (cadr (assoc keyword *keyword-html-functions* :test #'string-equal)))

(defun to-html (form &key (plain nil))
  (cond ((quoted-string-p form)
	 (write-span "string" form))
	((global-string-p form)
	 (write-span "variable-name" form))
	((keyword-string-p form)
	 (write-span "builtin" form))
	((char-string-p form)
	 (write-span "character" form))
	((comment-string-p form)
	 (write-span "comment" form))
	((stringp form)
	 (write-string (xml-escape form)))
	((and (listp form)
	      (whitespace-p (first form))
	      (stringp (second form)))
	 (let ((function (keyword-html-function (second form))))
	   (if plain
	       (progn (princ #\() (mapc #'(lambda (f) (to-html f :plain plain))
					form) (princ #\)))
	       (if function
		   (funcall function form)
		   (special-1-to-html form)))))
	((or (null form)
	     (and (listp form)
		  (whitespace-p (first form))
		  (null (second form))))
	 (princ #\() (princ #\)))
	((listp form)
	 (princ #\() (mapc #'(lambda (f) (to-html f :plain plain)) form) (princ #\)))
	(t (error "unknown type"))))

(defun htmlize-file (file &optional (output *standard-output*))
  (with-open-file (s file :direction :input)
    (htmlize s output)))

(defun htmlize-string (string output)
  (with-input-from-string (s string)
    (htmlize s output)))

(defun htmlize (input output)
  (let ((*standard-output* output))
    (write-string "<pre class=\"htmlize\">")
    (loop for form = (bknr-read input nil 'eof)
	  until (eq form 'eof)
	  do (to-html form))
    (write-string "</pre>")))
